
import java.awt.Color;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import ij.gui.Plot;


public class Diffusion {
///////////////////////////////Input Parameters////////////////

static final int height = 75;     //150   //300
static final int width = 75;	   //150   //300
static final int gap = 20;
static final int steps = 0; //steps added together before moving **if steps > 0, de-comment line in addArrays()
static final float stepSize = 0.5f;  //1.0   //0.5
static final int move = 1000000; //move n positions   
static final int nReceptors = 1; //should not exceed height*width 
static final int hopProb = 0; //0 to 100   //**if confining to inner boundary only, change eventCheck()
static final float concentration = 1.0f; //M     //0.000001f   0.0000000052f  K_off / K_on
static final float kOn = 27000.0f;   //M^-1 * s^-1   //270000.0f;  
static final float kOff = 0.00014f;  //s^1            //0.00014f; 
static final float timeStep = 0.0000003f; //0.0000003f;
static final int eventInterval = 1000;  //  interval based on move, not move*steps
static final int generateActive = 50;
///////////////////////////////////////////////////////////////

static final float[][] receptorArray = new float[nReceptors][3];
static final float[][] previousReceptorArray = new float[nReceptors][3];
static final float[][] moveArray = new float[nReceptors][3];
static final float[][] stepArray = new float[nReceptors][3];
static final float[][] stateArray = new float[nReceptors][move];
static final float[][] copyTotalTimeArray = new float[nReceptors][move];
static final float[] totalTimeArray = new float[move];



static ArrayList<Float> xArray = new ArrayList<Float>();
static ArrayList<Float> yArray = new ArrayList<Float>();
static ArrayList<Float> xOutArray = new ArrayList<Float>();
static ArrayList<Float> yOutArray = new ArrayList<Float>();
static ArrayList<Float> collisionArray = new ArrayList<Float>();
static ArrayList<Float> timePointArray = new ArrayList<Float>();
static ArrayList<Float> collisionPerTimeArray = new ArrayList<Float>();
static ArrayList<Float> switchStateArray = new ArrayList<Float>();
static ArrayList<Float> switchTimeArray = new ArrayList<Float>();

static ArrayList<Float> hopArray = new ArrayList<Float>();
static ArrayList<Float> hopTimeArray = new ArrayList<Float>();
static ArrayList<Float> hopOutXLocationArray = new ArrayList<Float>();
static ArrayList<Float> hopOutYLocationArray = new ArrayList<Float>();
static ArrayList<Float> hopInXLocationArray = new ArrayList<Float>();
static ArrayList<Float> hopInYLocationArray = new ArrayList<Float>();

static ArrayList<Float> eventXLocationArray = new ArrayList<Float>();
static ArrayList<Float> eventYLocationArray = new ArrayList<Float>();




static float xElements = 0.0f;
static float yElements = 0f;
static float timePoint = 0.0f;
static float eventPerTime = 0.0f;
static float totalTime = 0.0f;
static float hops = 0.0f;


static int a = 0;  


static ArrayList<Float> eventArray = new ArrayList<Float>();
static float events = 0;


	public static void main(String args[]) throws IOException{
		
		Thread t1 = new Thread(new Runnable(){
			
			@Override
			public void run(){
				long startTime1 =  System.currentTimeMillis();
						
				
				initialArray();
			
				checkArray();
				
				long endTime1 =  System.currentTimeMillis();
				long totalTime1 = endTime1 - startTime1;
				System.out.println("Current simulation runtime is: "+ totalTime1 +" milliseconds");
			}
			
		});
		Thread t2 = new Thread(new Runnable(){
			
			@Override 
			public void run(){
				long startTime2 =  System.currentTimeMillis();
				
				try {
					Thread.sleep(300);
				} catch (InterruptedException e) {
				
					e.printStackTrace();
				}
				
				FileOutputStream fileOS = null;
				
				try {
					fileOS = new FileOutputStream("C:\\Users\\Mike\\Documents\\BinaryFile.bin");
				} catch (FileNotFoundException e1) {
					
					e1.printStackTrace();
				}
				int recCheck = 0;
				for(int i = 0; i <= move - 1; i++){  //move i times
					
					 //pass things into method when method is called, so initialize variable first
					 //pass m into movementArray so that it can keep track of number
					 //of moves within method (for conjunction with stateSwitchArray)
					
						int m = i;
						if(m%1000 == 0){
						System.out.println("m: "+m);
						}
						
						movementArray(m);	
											
						//System.out.println(Arrays.deepToString(moveArray));
						//System.out.println("switchStateArray: "+switchStateArray);
						
					for (int x = 0; x <=receptorArray.length -  1; x++){
						for(int y = 0; y <=receptorArray[x].length - 1; y++){
							
							previousReceptorArray[x][y] = receptorArray[x][y];
						}
					}
						//System.out.println("recArray BEFORE addArray(): "+Arrays.deepToString(receptorArray));
						//System.out.println("prevRecArray BEFORE addArray(): "+Arrays.deepToString(previousReceptorArray));
						
						addArrays(m); 
						
						//System.out.println("recArray AFTER addArray(): "+Arrays.deepToString(receptorArray));
						//System.out.println("prevRecArray AFTER addArray(): "+Arrays.deepToString(previousReceptorArray));
							
						ByteArrayOutputStream bas = new ByteArrayOutputStream();
						DataOutputStream ds = new DataOutputStream(bas);
						
						
						while(recCheck == 0){
						try {
							ds.writeFloat(nReceptors);
							ds.writeFloat(steps);
							ds.writeFloat(move);
						} catch (IOException e1) {
							// TODO Auto-generated catch block
							e1.printStackTrace();
						}
						recCheck++;
						}
						for(int j = 0;  j <= receptorArray.length - 1; j++){
							for(int k = 0; k <= receptorArray[j].length - 1; k++){
							try {
								ds.writeFloat(receptorArray[j][k]);
								
							} catch (IOException e) {
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
										
							}
						}
						byte[] byteData = bas.toByteArray();
						
						
						try {
							fileOS.write(byteData, 0, byteData.length);
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
						try {
							fileOS.flush();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
			/////////////////////////////////////////////eventCheck()			
						boolean c = eventCheck();
						
						
						if(c == true){
						//takes timePoint when event occurs (when c == true)
						 timePoint = i*timeStep;
						
						 //tally's number of events at the ith timeStep
						 
						 eventPerTime++;
						 
						//System.out.println("Total number of events: "+events);
						//System.out.println("at time: "+timePoint+" seconds");
						//take data point every eventInterval moves
						}
						if( i%eventInterval == 0 ){
						
							//adds the count number to their respective arrays
							
							Float eventObject = new Float(events);
							Float timePointObject = new Float(timePoint);
							collisionArray.add(eventObject);
							timePointArray.add(timePointObject);
							collisionPerTimeArray.add(eventPerTime);
							
							//reset counter every interval
							eventPerTime = 0f;
							
						}
						
			
						for(int j = 0; j <= nReceptors - 1; j++){
							//System.out.println(receptorArray[j][0]);
							
							stateArray[j][i] = receptorArray[j][0];
						}
			//System.out.println("receptorArray: "+Arrays.deepToString(receptorArray));
			//System.out.println("stateArray: "+Arrays.deepToString(stateArray));
			
			totalTime = i*timeStep;
			
			totalTimeArray[i] = totalTime;
			//System.out.println("totalTime: "+totalTime);
			
			
			
			}  /////////////////////////////end of move for loop
	
				//System.out.println("stateArray: "+Arrays.deepToString(stateArray));
				//System.out.println("switchStateArray: "+switchStateArray);
				//System.out.println("switchTimeArray: "+switchTimeArray);
				//System.out.println("totalTimeArray: "+Arrays.toString(totalTimeArray));
				
			for(int i = 0; i<= nReceptors - 1; i++){
				for(int j = 0; j<= move - 1; j++){
					
					copyTotalTimeArray[i][j] = totalTimeArray[j];
				}	
			}
			
			//System.out.println("copyTotalTimeArray: "+Arrays.deepToString(copyTotalTimeArray));
			//System.out.println("events: "+events);
			//System.out.println(Arrays.deepToString(xPlot))
			//System.out.println("yArray is: "+yArray);
				try {
					fileOS.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				//System.out.println("collisionArray: "+collisionArray);
				//System.out.println("timePointArray: "+timePointArray);
				//System.out.println("collisionPerTimeArray: "+collisionPerTimeArray);
				
/////////////////////////////PLOTS/////////////////////////////////////////////
				
				//plotTrajectory();
				//plotEvents();
				plotStates();
				//plotStateChanges();
				//plotHop();
				//System.out.println(switchStateArray);
				long endTime2 =  System.currentTimeMillis();
				long totalTime2 = endTime2 - startTime2;
				System.out.println("Current simulation runtime is: "+ totalTime2 +" milliseconds");
			}
	});
		
		t1.start();
		t2.start();
	
		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e) {
			
			e.printStackTrace();
		}
								
				
	}	//main end
	
	 public static synchronized void initialArray(){
	
		 Random rand = new Random();
		 for(int i = 0; i <= nReceptors - 1; i++){
		
			//int randReceptor = rand.nextInt(2); //0 inactive, 1 active
			int randRow = rand.nextInt(height);//random row within height constraint 
			int randCol = rand.nextInt(width);//random column within width constraint 
		
				//receptorArray[i][0] = randReceptor;
			boolean goActive = randState();
			if (goActive == true){
				receptorArray[i][0] = 1.0f; ;
			}
			else{
				receptorArray[i][0] = 0.0f;
			}
				receptorArray[i][1] = randRow;
				receptorArray[i][2] = randCol;						
		}
		 	System.out.println("Initial Array is :");
			System.out.println(Arrays.deepToString(receptorArray)); 
			
	}/////////intialArray end
 	 
	 public static synchronized void checkArray(){// makes sure initialArray receptors don't occupy same spot initially
		 
		 
		 int jRandReplaceRow = 0;
		 int jRandReplaceCol = 0;
	
	
		 for(int i = 0; i <= receptorArray.length - 1; i++){
			 for(int j = 0; j <= receptorArray.length - 1; j++){
				 if(receptorArray[i][1] == receptorArray[j][1] && receptorArray[i][2] == receptorArray[j][2] && i != j){ //satisfied if there is a match
					    
						//System.out.println(receptorArray[i][1]+ " from " + i +" row "+ " matches " + receptorArray[j][1] + " from " + j + " row");
						//System.out.println(receptorArray[i][2]+ " from " + i +" column " + " matches " + receptorArray[j][2] + " from " + j + " column");

						int checkCount = 0;
						
						//if match, activate this for loop
						for(int k = 0; k <= receptorArray.length - 1; k++){
							
							jRandReplaceRow = jRow();
							jRandReplaceCol = jCol();
							if(receptorArray[k][1] == jRandReplaceRow && receptorArray[k][2] == jRandReplaceCol){//satisfied if random numbers match array elements									
							//System.out.println("current array pair " + receptorArray[k][1] + " and " + receptorArray[k][2] + " matches random " + jRandReplaceRow + " and " + jRandReplaceCol);
							//System.out.println("redo random numbers");
						
							jRandReplaceRow = jRow();
							jRandReplaceCol = jCol();
							k--;
							}
							else{
								//System.out.println("current array pair " + receptorArray[k][1] + " and " + receptorArray[k][2] + " doesn't match random " + jRandReplaceRow + " and " + jRandReplaceCol);
								
								checkCount++;
								//System.out.println("CheckCount: " + checkCount);
									if(checkCount == receptorArray.length){
										receptorArray[j][1] = jRandReplaceRow;
										receptorArray[j][2] = jRandReplaceCol;
										 //System.out.println("new receptor array is " + Arrays.deepToString(receptorArray));
									}
							}
						
						
						}//k loop end
						
				 }
				 else{ 
					continue;
				 }
			 }
		 }
     
	
  }////////checkArray() end
	 
	 
	//slightly modified, as checkArray() would could switch position of 
	//receptor already present instead of newly placed receptor
	//takes randomly generated position of new receptor if receptor hops in addArray() and 
	//compares to make sure it's not generated on occupied spot
public static void checkHopArray(int index){    
	
	System.out.println("receptorArray before check: "+Arrays.deepToString(receptorArray));
	System.out.println("index:  "+index);
	System.out.println(receptorArray[index][1]);
	System.out.println(receptorArray[index][2]);
	for(int i = 0; i <= receptorArray.length - 1; i++){
		
		if(receptorArray[i][1] == receptorArray[index][1] && receptorArray[i][2] == receptorArray[index][2] && i != index){
			//System.out.println("match at i: "+i);
			//System.out.println("match between receptorArray[i][1]: "+receptorArray[i][1] + " and receptorArray[index][1]"+receptorArray[index][1]);
			//System.out.println("match between receptorArray[i][2]: "+receptorArray[i][2] + " and receptorArray[index][2]"+receptorArray[index][2]);
			//int checkCount = 0;
			 receptorArray[index][1] = jRow();
			 receptorArray[index][2] = jCol();
			//System.out.println("new receptorArray[index][1]: "+receptorArray[index][1]);
			 //System.out.println("new receptorArray[index][2]: "+receptorArray[index][2]);
			 
			 //start over
			 i=0;		 
	}
		else{
			continue;
		}
  }
  System.out.println("receptorArray after check: "+Arrays.deepToString(receptorArray)); 
}
	 public static int jRow(){
		 Random randCheck = new Random();
		 int jRandRow = randCheck.nextInt(height);
		 
		 return jRandRow;
	 }///////jRow() end
	 
	 public static int jCol(){
		 Random randCheck = new Random();
		 int jRandCol = randCheck.nextInt(width);
		 
		 return jRandCol;
	 }///////jCol() end
	 
	 public static boolean randState(){
		 
		 Random rand = new Random();
		 int randState = rand.nextInt(100);
		 
		 if (randState < generateActive){
		 return true; 
		 }
		 return false;
	 }
	
	 public static boolean switchActive(){
		 
		 //increase concentration as variable with for loop later
	
		 float pOn = kOn*concentration*timeStep*100;  //%
			 
		 //System.out.println("pOn: "+pOn+"%");
		 
		 String strFloat = String.valueOf(pOn);
		 //System.out.println("strFloat: "+strFloat);
		 
		 int count = strFloat.indexOf('.');
		 //System.out.println("index of decimal: "+count);
		 
		 int decimalPlaces = strFloat.length() - count - 1;
		 //System.out.println("number of decimal places: "+decimalPlaces);
		 
		 float multiplier =  (float) Math.pow(10,decimalPlaces);
		 
		//System.out.println("multiplier: "+multiplier);
		//System.out.println("switchActive(): "+pOn*multiplier+" / "+100*multiplier);
		 //float aFraction = (pOn*multiplier)/(100*multiplier);
		//System.out.println("fraction: "+aFraction);
		 
		 
		Random randActive = new Random();
		
		int switchOn = randActive.nextInt((int) (100*multiplier));	 
		//System.out.println("switchActive() random number is: "+switchOn);
		 
		 if(switchOn < pOn*multiplier){
			 //System.out.println("switch on");
		 return true;
		 }
		
			//System.out.println("dont switch on");
		return false;
		 
	 }///////switchActive() end
	 
	 public static boolean switchInactive(){
		 
		 float pOff = kOff*timeStep*100;  //%
		 //System.out.println("pOff: "+pOff+"%");
		 
		 String strFloat = String.valueOf(pOff);
		 //System.out.println("strFloat: "+strFloat);
		 
		 int count = strFloat.indexOf('.');
		 //System.out.println("index of decimal: "+count);
		 
		 int decimalPlaces = strFloat.length() - count - 1;
		 //System.out.println("number of decimal places: "+decimalPlaces);
		 
		 float multiplier =  (float) Math.pow(10,decimalPlaces);
		 
		 //System.out.println("multiplier: "+multiplier);
		 //System.out.println("switchInactive(): "+pOff*multiplier+" / "+100*multiplier);
		 //float aFraction = (pOff*multiplier)/(100*multiplier);
		 //System.out.println("fraction: "+aFraction);
		 
		Random randInactive = new Random();
		
		float switchOff = randInactive.nextInt((int) (100*multiplier));	 
		//System.out.println("switchInactive() random number is: "+switchOff);
		 
		 if(switchOff < pOff*multiplier){
			 //System.out.println("switch off");
		 return true;
		 }
		 //System.out.println("don't switch off");
		return false;
		 
	 }///////switchInactive end
	 
	 
	 public static synchronized void movementArray(int mm){
		 Random rand = new Random();
		 //value of m passed into this method as mm (mm variable takes value of m)
		 //skipping receptors wont affect moveCount if place if statement after moveCount
		 //so that moveCount can still be be counted to be converted to time
		 int moveCount = mm +a;
		 
				
			for(int i = 0; i <= moveArray.length - 1; i++){	
								
				
					//System.out.println("moveCount: "+moveCount);
					//System.out.println("mm: "+mm);
					//System.out.println("moveArray i: "+i);
				//System.out.println("moveArray beginning of loop: "+Arrays.deepToString(moveArray));
				 int randMove = rand.nextInt(2);
				 int randDir = rand.nextInt(2);
				
				// System.out.println("randMove is: " + randMove);
				 
				 //receptorArray state carried over to moveArray state
				 moveArray[i][0] = receptorArray[i][0];
				 
				 
				 //float randState = rand.nextInt((int) (2));
				 //moveArray[i][0] = randState;
				 
				//System.out.println("Initial moveArray state: "+moveArray[i][0]);
				 
				 if(randMove == 0){  //row change
					if(randDir == 0){  //negative value	
					 moveArray[i][1] = -stepSize;  
					 	
					 	if(moveArray[i][0] == 0.0f || moveArray[i][0] == 0.1f){  //if receptor is inactive
					 		//System.out.println("AAAinitial moveArray state  0: "+moveArray[i][0]);
					 		
					 		boolean on = switchActive();	
							if(on == true){
								if(moveArray[i][0] == 0.0f){
								//System.out.println("AAAswitch to ACTIVE");	
								moveArray[i][0] = 1.0f;  //switch to active
								switchStateArray.add(moveArray[i][0]);
								switchTimeArray.add((float) moveCount*timeStep);
								//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
								//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
								///System.out.println("AAAnew moveArray state  1: "+moveArray[i][0]);
								 a++;
								}
								else if(moveArray[i][0] == 0.1f){
									moveArray[i][0] = 1.1f;
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									a++;
								}
							}
							else if(on == false){
								
								//System.out.println("AAAstay INACTIVE");
								//System.out.println("AAAnew moveArray state  0: "+moveArray[i][0]);
								 a++;							
							} 
					 	}
					 	else if(moveArray[i][0] == 1.0f || moveArray[i][0] == 1.1f){   //if receptor is active
					 		//System.out.println("BBBinitial moveArray state  1: "+moveArray[i][0]);
							boolean off = switchInactive();
							if(off == true){
								if(moveArray[i][0] == 1.0f){
									//System.out.println("BBBswitch to INACTIVE");
									moveArray[i][0] = 0.0f;
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("BBBnew moveArray state  0: "+moveArray[i][0]);
									 a++;
								}
								else if(moveArray[i][0] == 1.1f){
									//System.out.println("BBBswitch to INACTIVE");
									moveArray[i][0] = 0.1f;
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("BBBnew moveArray state  0: "+moveArray[i][0]);
									 a++;
								}
							}
							else if(off == false){
								//System.out.println("BBBstay ACTIVE");
						
								//System.out.println("BBBnew moveArray state  1: "+moveArray[i][0]);
								 a++;
							}
					 	}			
					}
				 
					if(randDir == 1){//positive value
					  moveArray[i][1] = stepSize;
					  
					  if(moveArray[i][0] == 0.0f || moveArray[i][0] == 0.1f){  //if receptor is inactive
						  //System.out.println("CCCinitial moveArray state  0: "+moveArray[i][0]);
						  boolean on = switchActive();
							if(on == true){
								if(moveArray[i][0] == 0.0f){
								//System.out.println("CCCswitch to ACTIVE");
								moveArray[i][0] = 1.0f;  //switch to active
								switchStateArray.add(moveArray[i][0]);
								switchTimeArray.add((float) moveCount*timeStep);
								//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
								//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
								//System.out.println("CCCnew moveArray state  1: "+moveArray[i][0]);
								 a++;
								}
								else if(moveArray[i][0] == 0.1f){
									//System.out.println("CCCswitch to ACTIVE");
									moveArray[i][0] = 1.1f;  //switch to active
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("CCCnew moveArray state  1: "+moveArray[i][0]);
									 a++;
								}
							}
							else if(on == false){
								//System.out.println("CCCstay INACTIVE");
					
								//System.out.println("CCCnew moveArray state  0: "+moveArray[i][0]);
								 a++;
							}
						}
						 
					  else if(moveArray[i][0] == 1.0f || moveArray[i][0] == 1.1f){   //if receptor is active
						  //System.out.println("DDDinitial moveArray state  1: "+moveArray[i][0]);
							 boolean off = switchInactive(); //0 to 99
							 if(off == true){
								 if(moveArray[i][0] == 1.0f){
									 //System.out.println("DDDswitch to INACTIVE");
									 moveArray[i][0] = 0.0f;
									 switchStateArray.add(moveArray[i][0]);
									 switchTimeArray.add((float) moveCount*timeStep);
									 //System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									 //System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									 //System.out.println("DDDnew moveArray state  0: "+moveArray[i][0]);
									  a++;
								 }
								 else if(moveArray[i][0] == 1.1f){
									 //System.out.println("DDDswitch to INACTIVE");
									 moveArray[i][0] = 0.1f;
									 switchStateArray.add(moveArray[i][0]);
									 switchTimeArray.add((float) moveCount*timeStep);
									 //System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									 //System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									 //System.out.println("DDDnew moveArray state  0: "+moveArray[i][0]);
									  a++;
								 }
								
							 }
							 else if(off == false){
								 //System.out.println("DDDstay ACTIVE");
							
								 //System.out.println("DDDnew moveArray state  1: "+moveArray[i][0]);
								 a++;
							 }
						 }
					}
				 }
				
				 if(randMove == 1){  //column change
					 if(randDir == 0){  //negative value	
					 moveArray[i][2] = -stepSize;
					 
					 	if(moveArray[i][0] == 0.0f || moveArray[i][0] == 0.1f){  //if receptor is inactive
					 		 //System.out.println("EEEinitial moveArray state  0: "+moveArray[i][0]);
							boolean on = switchActive();
							if(on == true){		//switch to active
								if(moveArray[i][0] == 0.0f){
									//System.out.println("EEEswitch to ACTIVE");
									moveArray[i][0] = 1.0f;  //switch to active
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("EEEnew moveArray state  1: "+moveArray[i][0]);
									a++;
								}
								else if(moveArray[i][0] == 0.1f){
									//System.out.println("EEEswitch to ACTIVE");
									moveArray[i][0] = 1.1f;  //switch to active
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("EEEnew moveArray state  1: "+moveArray[i][0]);
									a++;
								}
								
							}
							else if(on == false){  //stay inactive
								//System.out.println("EEEstay INACTIVE");
							
								//System.out.println("EEEnew moveArray state  0: "+moveArray[i][0]);
								a++;
							}
						}
						 
					 	else if(moveArray[i][0] == 1.0f || moveArray[i][0] == 1.1f){   //if receptor is active
					 		//System.out.println("FFFinitial moveArray state  1: "+moveArray[i][0]);
							 boolean off = switchInactive(); 
							 if(off == true){
								 if(moveArray[i][0] == 1.0f){
									//System.out.println("FFFswitch to INACTIVE");
									 moveArray[i][0] = 0.0f;
									 switchStateArray.add(moveArray[i][0]);
									 switchTimeArray.add((float) moveCount*timeStep);
									 //System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									 //System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									 //System.out.println("FFFnew moveArray state  0: "+moveArray[i][0]);
									 a++;
								 }
								 else if(moveArray[i][0] == 1.1f){
									 //System.out.println("FFFswitch to INACTIVE");
									 moveArray[i][0] = 0.1f;
									 switchStateArray.add(moveArray[i][0]);
									 switchTimeArray.add((float) moveCount*timeStep);
									 //System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									 //System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									 //System.out.println("FFFnew moveArray state  0: "+moveArray[i][0]);
									 a++;
								 }
								
							 }
							 else if(off == false){
								 //System.out.println("FFFstay ACTIVE");
							
								 //System.out.println("FFFnew moveArray state  1: "+moveArray[i][0]); 
								a++;
							 }
						 }
					 }
					 if(randDir == 1){//positive value
					 moveArray[i][2] = stepSize;
					 
					 	if(moveArray[i][0] == 0.0f || moveArray[i][0] == 0.1f){  //if receptor is inactive
					 		//System.out.println("GGGinitial moveArray state  0: "+moveArray[i][0]);
							boolean on = switchActive();
							if(on == true){
								if(moveArray[i][0] == 0.0f){
									//System.out.println("GGGswitch to ACTIVE");
									moveArray[i][0] = 1.0f;  //switch to active
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("GGGnew moveArray state  1: "+moveArray[i][0]);
									a++;
								}else if(moveArray[i][0] == 0.1f){
									//System.out.println("GGGswitch to ACTIVE");
									moveArray[i][0] = 1.1f;  //switch to active
									switchStateArray.add(moveArray[i][0]);
									switchTimeArray.add((float) moveCount*timeStep);
									//System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									//System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									//System.out.println("GGGnew moveArray state  1: "+moveArray[i][0]);
									a++;
								}
								
							}
							else if(on == false){
								//System.out.println("GGGstay INACTIVE");
							
								//System.out.println("GGGnew moveArray state  0: "+moveArray[i][0]);
								a++;
							}
						}
						 
					 	else if(moveArray[i][0] == 1.0f || moveArray[i][0] == 1.1f){   //if receptor is active
					 		//System.out.println("HHHinitial moveArray state  1: "+moveArray[i][0]);
							 boolean off = switchInactive(); 
							 if(off == true){
								 if(moveArray[i][0] == 1.0f){
									 //System.out.println("HHHswitch to INACTIVE");
									 moveArray[i][0] = 0.0f;
									 switchStateArray.add(moveArray[i][0]);
									 switchTimeArray.add((float) moveCount*timeStep);
									 //System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									 //System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									 //System.out.println("HHHnew moveArray state  0: "+moveArray[i][0]);
									 a++;
								 }
								 else if(moveArray[i][0] == 1.1f){
									//System.out.println("HHHswitch to INACTIVE");
									 moveArray[i][0] = 0.1f;
									 switchStateArray.add(moveArray[i][0]);
									 switchTimeArray.add((float) moveCount*timeStep);
									 //System.out.println("moveCount: "+moveCount+"  timeStep: "+ timeStep);
									 //System.out.println("moveCount*timeStep: "+moveCount*timeStep);
									 //System.out.println("HHHnew moveArray state  0: "+moveArray[i][0]);
									 a++;
								 }						
							 }
							 else if(off == false){
								 //System.out.println("HHHstay ACTIVE");
					
								 //System.out.println("HHHnew moveArray state  1: "+moveArray[i][0]);
								 a++;
							 }
						 }
					 }
				 }
				//System.out.println("moveArray after move loop: "+Arrays.deepToString(moveArray));
				 //System.out.println("New moveArray state: "+moveArray[i][0]);
				} ///////////////end of moveArray for loop
		
			
			//System.out.println("after move a: "+a);
			
			
//control number of steps added to moveArray until moveArray is added to receptorArray	
//each k iteration generates 1 stepArray and adds it to moveArray 
		for(int k = 0; k <= steps - 1; k++){  
		  //System.out.println("k steps: "+k);
			for(int i = 0; i <= stepArray.length - 1; i++){
				
				moveCount++;//// seems to have fixed issue...... work for multiple k steps??
				//multiply plot data by steps to scale time appropriately, b/c when stepArrays are 
				//added to moveArray, the time doesn't scale with the iterations
				
				//System.out.println("inside step a: "+a);
			
				//state of moveArray is carried over to stepArray 
				//without this, state would default to 0.0 and overwrite moveArray state
				//when moveArray[i][0] is set equal to stepArray[i][0] at bottom of method
				stepArray[i][0] = moveArray[i][0];
				
				//System.out.println("CHECK MATCH  initial stepArray[i][0]: "
				//+stepArray[i][0]+ " moveArray[i][0]: "+moveArray[i][0]);
				 int randMove = rand.nextInt(2);
				 int randDir = rand.nextInt(2);
				 //System.out.println("randMove is: " + randMove);
				 
				 //float randState = rand.nextInt((int) (2));
				 //stepArray[i][0] = randState;
						 
				 if(randMove == 0){//row change
					if(randDir == 0){//negative value		
					  stepArray[i][1] = -stepSize;  
					  
					  if(stepArray[i][0]== 0.0f){  //if receptor is inactive
						  //System.out.println("IIIinitial stepArray state 0: "+stepArray[i][0]);
							boolean on = switchActive();
							if(on == true){
							
								//System.out.println("IIIswitch to ACTIVE");
								stepArray[i][0] = 1.0f;  //switch to active
								//System.out.println("inside boolean step  a: "+a);
								switchStateArray.add(stepArray[i][0]);
								switchTimeArray.add((float)  (moveCount)*timeStep);
								//System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								//System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								//System.out.println("IIInew stepArray state 1: "+stepArray[i][0]);
							}
							else if(on == false){
							
								//System.out.println("IIIstay INACTIVE");
								stepArray[i][0] = 0.0f;
								 //System.out.println("IIInew stepArray state 0: "+stepArray[i][0]);
							}
						}
						 
					  else if(stepArray[i][0] == 1.0f){   //if receptor is active
						  //System.out.println("JJJinitial stepArray state 1: "+stepArray[i][0]);
							 boolean off = switchInactive(); 
							 if(off == true){
								 
								 //System.out.println("JJJswitch to INACTIVE");
								 stepArray[i][0] = 0.0f;
								 //System.out.println("inside boolean step  a: "+a);
								 switchStateArray.add(stepArray[i][0]);
								 switchTimeArray.add((float)  (moveCount)*timeStep);
								 //System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								 //System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								 //System.out.println("JJJnew stepArray state 0: "+stepArray[i][0]);
							 }
							 else if(off == false){
								
								 //System.out.println("JJJstay ACTIVE");
								 stepArray[i][0] = 1.0f;
								 //System.out.println("JJJnew stepArray state 1: "+stepArray[i][0]);
							 }
						 }
					}
					if(randDir == 1){//positive value
					  stepArray[i][1] = stepSize;
					  
					  if(stepArray[i][0]== 0.0f){  //if receptor is inactive
						  //System.out.println("KKKinitial stepArray state 0: "+stepArray[i][0]);
							boolean on = switchActive();
							if(on == true){
								
								//System.out.println("KKKswitch to ACTIVE");
								stepArray[i][0] = 1.0f;  //switch to active
								//System.out.println("inside boolean step  a: "+a);
								switchStateArray.add(stepArray[i][0]);
								switchTimeArray.add((float)  (moveCount)*timeStep);
								//System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								//System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								//System.out.println("KKKnew stepArray state 1: "+stepArray[i][0]);
							}
							else if(on == false){
								
								//System.out.println("KKK stay INACTIVE");
								stepArray[i][0] = 0.0f;
								//System.out.println("KKKnew stepArray state 0: "+stepArray[i][0]);
							}
						}
						 
					  else if(stepArray[i][0] == 1.0f){   //if receptor is active
						  //System.out.println("LLLinitial stepArray state 1: "+stepArray[i][0]);
							 boolean off = switchInactive(); 
							 if(off == true){
								 
								 //System.out.println("LLLswitch to INACTIVE");
								 stepArray[i][0] = 0.0f;
								 //System.out.println("inside boolean step  a: "+a);
								 switchStateArray.add(stepArray[i][0]);
								 switchTimeArray.add((float)  (moveCount)*timeStep);
								 //System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								 //System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								 //System.out.println("LLLnew stepArray state 0: "+stepArray[i][0]);
							 }
							 else if(off == false){
								
								 //System.out.println("LLLstay ACTIVE");
								 stepArray[i][0] = 1.0f;
								 //System.out.println("LLLnew stepArray state 1: "+stepArray[i][0]);
								 
							 }
						 }
					}
				 }
				 if(randMove == 1){//column change
					 if(randDir == 0){//negative value			
					 stepArray[i][2] = -stepSize;
					 
					 	if(stepArray[i][0]== 0.0f){  //if receptor is inactive
					 		//System.out.println("MMMinitial stepArray state 0: "+stepArray[i][0]);
							boolean on = switchActive();
							if(on == true){
								
								//System.out.println("MMMswitch to ACTIVE");
								stepArray[i][0] = 1.0f;  //switch to active
								//System.out.println("inside boolean step  a: "+a);
								switchStateArray.add(stepArray[i][0]);
								switchTimeArray.add((float) (moveCount)*timeStep);
								//System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								//System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								//System.out.println("MMMnew stepArray state 1: "+stepArray[i][0]);
							}
							else if (on == false){
								
								//System.out.println("MMMstay INACTIVE");
								stepArray[i][0] = 0.0f;
								//System.out.println("MMMnew stepArray state 0: "+stepArray[i][0]);
							}
						}
						 
					 	else if(stepArray[i][0] == 1.0f){   //if receptor is active
					 		  //System.out.println("NNNinitial stepArray state 1: "+stepArray[i][0]);
							boolean off = switchInactive(); 
							 if(off == true){
								
								 //System.out.println("NNNswitch to INACTIVE");
								 stepArray[i][0] = 0.0f;
								 //System.out.println("inside boolean step  a: "+a);
								 switchStateArray.add(stepArray[i][0]);
								 switchTimeArray.add((float)  (moveCount)*timeStep);
								 //System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								 //System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								 //System.out.println("NNNnew stepArray state 0: "+stepArray[i][0]);
							 }
							 else if(off == false){
								 
								 //System.out.println("NNNstay ACTIVE");
								 stepArray[i][0] = 1.0f;
								 //System.out.println("NNNnew stepArray state 1: "+stepArray[i][0]);
							 }
						 }
					 }
					 if(randDir == 1){//positive value
					 stepArray[i][2] = stepSize;
					 
					 	if(stepArray[i][0]== 0.0f){  //if receptor is inactive
					 		//System.out.println("OOOinitial stepArray state 0: "+stepArray[i][0]);
							boolean on = switchActive();
							if(on == true){
								
								//System.out.println("OOOswitch to ACTIVE");
								stepArray[i][0] = 1.0f;  //switch to active
								//System.out.println("inside boolean step  a: "+a);
								switchStateArray.add(stepArray[i][0]);
								switchTimeArray.add((float)  (moveCount)*timeStep);
								//System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								//System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								//System.out.println("OOOnew stepArray state 1: "+stepArray[i][0]);
							}
							else if(on == false){
								
								//System.out.println("OOOstay INACTIVE");
								stepArray[i][0] = 0.0f;
								//System.out.println("OOOnew stepArray state 0: "+stepArray[i][0]);
							}
						}
						 
					 	else if(stepArray[i][0] == 1.0f){   //if receptor is active
					 		 //System.out.println("PPPinitial stepArray state 1: "+stepArray[i][0]);
							boolean off = switchInactive(); //0 to 99
							 if(off == true){
								
								 //System.out.println("PPPswitch to INACTIVE");
								 stepArray[i][0] = 0.0f;
								 //System.out.println("inside boolean step  a: "+a);
								 switchStateArray.add(stepArray[i][0]);
								 switchTimeArray.add((float)  (moveCount)*timeStep);
								 //System.out.println("stepCount: "+(moveCount)+"  timeStep: "+ timeStep);
								 //System.out.println("stepCount*timeStep: "+(moveCount)*timeStep);
								 //System.out.println("PPPnew stepArray state 0: "+stepArray[i][0]);
							 }
							 else if(off == false){
								
								 //System.out.println("PPPstay ACTIVE");
								 stepArray[i][0] = 1.0f;
								 //System.out.println("PPPnew stepArray state 1: "+stepArray[i][0]);
							 }
						 }
					 }
				 }
			//System.out.println("stepArray inside i loop: "+Arrays.deepToString(stepArray));
		}////////////////////end of i step for loop
			
		//System.out.println("Movement array BEFORE step addition is: ");
		//System.out.println(Arrays.deepToString(moveArray));
		//System.out.println("Step array is: ");
		//System.out.println(Arrays.deepToString(stepArray));

		for(int i = 0; i <= moveArray.length - 1; i++){
			//moveArray is first step
			//stepArray is subsequent step, so final state is given by stepArray
			//set equal to moveArray since moveArray is what's added to receptorArray
					
////////////*** Only de-comment if using steps.  Otherwise, if steps = 0, no
///////////states are generated, and state defaults to zero***////////////////////////
			
			//moveArray[i][0] = stepArray[i][0];
				
/////////////////////////////////////////////////////////////////////////////////////			
			
			moveArray[i][1] = moveArray[i][1] + stepArray[i][1];
			moveArray[i][2] = moveArray[i][2] + stepArray[i][2];
			//System.out.println("stepArray state: "+ stepArray[i][0]+"  moveArray state: "+moveArray[i][0]);
			//System.out.println("moveArray state: "+ moveArray[i][0]);
		
		}			
		for(int i = 0; i < stepArray.length; i++){
			Arrays.fill(stepArray[i], '\0');
		}
		//System.out.println("Movement array AFTER step addition is: ");
		//System.out.println(Arrays.deepToString(moveArray));
		//System.out.println("cleared step array is: " + Arrays.deepToString(stepArray));
		
	 }//////////////////////////////end of k step for loop
 }/////////movementArray() end
	 

	 
	 public static boolean hopProbability(){
		 
		 Random rand = new Random();
		 
		 int randHop = rand.nextInt(100); // 0 to 99
		 //System.out.println(randHop);
		 
		 if(randHop < hopProb){
			 //System.out.println("Hop");
			 return true;
			 
		 }
		 	 //System.out.println("Don't hop");
		 return false;
		 
	 }

	 public static synchronized void addArrays(int mm){
		
		 float RandReplaceRow = 0.0f;
		 float RandReplaceCol = 0.0f;
		 //System.out.println("addArrays mm: "+mm);
		 
		
		 for (int i = 0; i <= moveArray.length - 1; i++){
								 
			 receptorArray[i][0] = moveArray[i][0];
			 //System.out.println(moveArray[i][0]);
			 //System.out.println("receptorArray before addition: "+Arrays.deepToString(receptorArray));
			 receptorArray[i][1] = receptorArray[i][1] + moveArray[i][1];
			 receptorArray[i][2] = receptorArray[i][2] + moveArray[i][2];
			 //System.out.println("receptorArray after addition: "+Arrays.deepToString(receptorArray));
			 
			// System.out.println("receptorArray before bound check: "+Arrays.deepToString(receptorArray));
			 
			
		  if(receptorArray[i][0] == 0.0f || receptorArray[i][0] == 1.0f){  
			  //inner to outer boundary condition
			  //System.out.println("INNER recArray to check :"+Arrays.toString(receptorArray[i]));
			 
			 //BOUNDARY CHECKING
			 if(receptorArray[i][1] < 0){
				 				 
				 //System.out.println("111before hop x: "+receptorArray[i][1]);
				//System.out.println("111before hop y: "+receptorArray[i][2]);
				 boolean hop = hopProbability();
				 if(hop == true){ //hop 
					 
					 //System.out.println("111receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));	 
					 hopOutXLocationArray.add(0.0f);
					 hopOutYLocationArray.add(receptorArray[i][2]);
					 hops++;
					 hopArray.add(hops);
					 hopTimeArray.add((float) mm*timeStep);			
					// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
					 if(receptorArray[i][0] == 1.0f){
						 receptorArray[i][0] = 1.1f;
					 }
					 else if(receptorArray[i][0] == 0.0f){
						 receptorArray[i][0] = 0.1f;
					 }
					 //System.out.println("111receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
					 
					 
//**for regenerating a new receptor when one hops, but may use later**//
					 //when one receptor leaves area and new one comes in
//					 RandReplaceRow = jRow();
//					 RandReplaceCol = jCol();
//					 
//					 
//					 boolean goActive = randState();
//					 if(goActive == true){
//					receptorArray[i][0] = 1.0f;
//					 }
//					 else{
//						 receptorArray[i][0] = 0.0f;
//					 }
					//receptorArray[i][1] = RandReplaceRow;
					//receptorArray[i][2] = RandReplaceCol;
					//System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray)); 
					//System.out.println("111after hop x: "+receptorArray[i][1]);
					//System.out.println("111after hop y: "+receptorArray[i][2]);
					
					//checkHopArray(i);
					//System.out.println("111after checkHopArray x: "+receptorArray[i][1]);
					//System.out.println("111after checkHopAray y: "+receptorArray[i][2]);
				 }
				 else{			  //don't hop
				 //System.out.println("111don't hop BEFORE: "+Arrays.deepToString(receptorArray));
				 receptorArray[i][1] = 0;
				 //receptorArray[i][1] = (0 + stepSize);
				 //System.out.println("111don't hop AFTER: "+Arrays.deepToString(receptorArray));
				 }
			 }
			 
			 //BOUNDARY CHECKING
			 else if(receptorArray[i][1] > width){	
				
				 
				 //System.out.println("222before hop x: "+receptorArray[i][1]);
				 //System.out.println("222before hop y: "+receptorArray[i][2]);
				 boolean hop = hopProbability();
				 if(hop == true){  //hop
					 
					 //System.out.println("222receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
							 
					 hopOutXLocationArray.add((float) width);
					 hopOutYLocationArray.add(receptorArray[i][2]);
					 hops++;
					 hopArray.add(hops);
					 hopTimeArray.add((float) mm*timeStep);
					// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
					 if(receptorArray[i][0] == 1.0f){
						 receptorArray[i][0] = 1.1f;
					 }
					 else if(receptorArray[i][0] == 0.0f){
						 receptorArray[i][0] = 0.1f;
					 }
					 //System.out.println("222receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
					 
//**for regenerating a new receptor when one hops, but may use later**// 
					 //when one receptor leaves area and new one comes in
//					 RandReplaceRow = jRow();
//					 RandReplaceCol = jCol();
//					 
//					
//					 boolean goActive = randState();
//					 if(goActive == true){
//					 receptorArray[i][0] = 1.0f;
//					 }
//					 else{
//						 receptorArray[i][0] = 0.0f;
//					 }
					//receptorArray[i][1] = RandReplaceRow;
					//receptorArray[i][2] = RandReplaceCol;		
					//System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray));
					//System.out.println("222after hop x: "+receptorArray[i][1]);
					//System.out.println("222after hop y: "+receptorArray[i][2]);
				
					//checkHopArray(i);
					//System.out.println("222after checkHopArray x: "+receptorArray[i][1]);
					//System.out.println("222after checkHopArray y: "+receptorArray[i][2]);
				 }
				 else{			   //don't hop
					 //System.out.println("222don't hop BEFORE: "+Arrays.deepToString(receptorArray));
					 receptorArray[i][1] = width;
				     //receptorArray[i][1] = (width - stepSize);
				 //System.out.println("222don't hop AFTER: "+Arrays.deepToString(receptorArray));
				 }
			 } 
			 /////////////////receptorArray[i][2] = receptorArray[i][2] + moveArray[i][2];
			 
			 //BOUNDARY CHECKING		
			 if(receptorArray[i][2] < 0){
				 
				 
				//System.out.println("333before hop x: "+receptorArray[i][1]);
				//System.out.println("333before hop y: "+receptorArray[i][2]);
				 boolean hop = hopProbability();
				 if(hop == true){  //hop
					 
					//System.out.println("333receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
				
					 hopOutXLocationArray.add(receptorArray[i][1]);
					 hopOutYLocationArray.add(0.0f);
					 hops++;
					 hopArray.add(hops);
					 hopTimeArray.add((float) mm*timeStep);
					// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
					 if(receptorArray[i][0] == 1.0f){
						 receptorArray[i][0] = 1.1f;
					 }
					 else if(receptorArray[i][0] == 0.0f){
						 receptorArray[i][0] = 0.1f;
					 }
					 //System.out.println("333receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
					 
//**for regenerating a new receptor when one hops, but may use later**//
					 //when one receptor leaves area and new one comes in
//					 RandReplaceRow = jRow();
//					 RandReplaceCol = jCol();
//				
//					
//					 boolean goActive = randState();
//					 if(goActive == true){
//					 receptorArray[i][0] = 1.0f;
//					 }
//					 else{
//						 receptorArray[i][1] = 0.0f;
//					 }
					//receptorArray[i][1] = RandReplaceRow;
					//receptorArray[i][2] = RandReplaceCol;	
					//System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray));
					//System.out.println("333after hop x: "+receptorArray[i][1]);
					//System.out.println("333after hop y: "+receptorArray[i][2]);
				
					//checkHopArray(i);
					//System.out.println("333after checkHopArray x: "+receptorArray[i][1]);
					//System.out.println("333after checkHopArray y: "+receptorArray[i][2]);
				 }
				 else{			   //don't hop
				    //System.out.println("333don't hop BEFORE: "+Arrays.deepToString(receptorArray));
				    receptorArray[i][2] = 0;
				    //receptorArray[i][2] = (0 + stepSize);
				    //System.out.println("333don't hop AFTER: "+Arrays.deepToString(receptorArray));
				 }
			 }
			 
			 //BOUNDARY CHECKING
			 else if(receptorArray[i][2] > height){
				 
				 
				 //System.out.println("444before hop x: "+receptorArray[i][1]);
				 //System.out.println("444before hop y: "+receptorArray[i][2]);
				 boolean hop = hopProbability();
				 if(hop == true){  //hop
		
					 //System.out.println("444receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
					 	
					 hopOutXLocationArray.add(receptorArray[i][1]);
					 hopOutYLocationArray.add((float) height);
					 hops++;
					 hopArray.add(hops);
					 hopTimeArray.add((float) mm*timeStep);
					// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
					 if(receptorArray[i][0] == 1.0f){
						 receptorArray[i][0] = 1.1f;
					 }
					 else if(receptorArray[i][0] == 0.0f){
						 receptorArray[i][0] = 0.1f;
					 }
					 //System.out.println("444receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
					 
//**for regenerating a new receptor when one hops, but may use later**//
					 //when one receptor leaves area and new one comes in
//					 RandReplaceRow = jRow();
//					 RandReplaceCol = jCol();
//					 
//					
//					 boolean goActive = randState();
//					 if(goActive == true){
//						 receptorArray[i][0] = 1.0f;				 
//					 }
//					 else{
//						 receptorArray[i][0] = 0.0f;
//					 }
					
					 //receptorArray[i][1] = RandReplaceRow;
					 //receptorArray[i][2] = RandReplaceCol;	
					 //System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray));
					 //System.out.println("444after hop x: "+receptorArray[i][1]);
					 //System.out.println("444after hop y: "+receptorArray[i][2]);
				
					 //checkHopArray(i);
					 //System.out.println("444after checkHopArray x: "+receptorArray[i][1]);
					 //System.out.println("444after checkHopArray y: "+receptorArray[i][2]);
				 }
				 else{			   //don't hop
				  //System.out.println("444don't hop BEFORE: "+Arrays.deepToString(receptorArray));
				    receptorArray[i][2] = height;
				  //receptorArray[i][2] = (height - stepSize);
				    //System.out.println("444don't hop AFTER: "+Arrays.deepToString(receptorArray));
				 }
			 }  
//////////////***zz		
//			 xElements = receptorArray[i][1];//////////////////////////zz
//			 yElements = receptorArray[i][2];//////////////////////////zz
//			//System.out.println("moveArray size: "+(moveArray.length-1));
//			//System.out.println("xElement: "+xElements);
//					 
//			 xArray.add(xElements);///////////////////////////////////zz
//			 yArray.add(yElements);///////////////////////////////////zz
//			//System.out.println("hopTimeArray: "+hopTimeArray);
//			 // System.out.println("xArray is: ");
//			// System.out.println(xArray);
//////////////***zz			 
			 
		 }/////////** END OF if(0.0f or 1.0f)**////////
		  
		  else if(receptorArray[i][0] == 0.1f || receptorArray[i][0] == 1.1f){
			  //outer to inner boundary condition
			  //System.out.println("OUTER recArray to check :"+Arrays.toString(receptorArray[i]));
				 //BOUNDARY CHECKING
				 if(receptorArray[i][1] < width && receptorArray[i][1] > 0 && receptorArray[i][2] > 0 
						 && receptorArray[i][2] < height && previousReceptorArray[i][1] <= 0){ //hop in from right
					 				 
					 //System.out.println("111before hop x: "+receptorArray[i][1]);
					//System.out.println("111before hop y: "+receptorArray[i][2]);
					 boolean hop = hopProbability();
					 if(hop == true){ //hop inside
						 									 
						//System.out.println("555prevRecArray BEFORE hop: "+Arrays.deepToString(previousReceptorArray));
						//System.out.println("555receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
						 				 
						 hopInXLocationArray.add(0.0f);
						 hopInYLocationArray.add(receptorArray[i][2]);
						 hops++;
						 hopArray.add(hops);
						 hopTimeArray.add((float) mm*timeStep);			
						// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
						 if(receptorArray[i][0] == 1.1f){
							 receptorArray[i][0] = 1.0f;
						 }
						 else if(receptorArray[i][0] == 0.1f){
							 receptorArray[i][0] = 0.0f;
						 }
						 //System.out.println("555prevRecArray AFTER hop: "+Arrays.deepToString(previousReceptorArray));
						 //System.out.println("555receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
						 
	//**for regenerating a new receptor when one hops, but may use later**//
						 //when one receptor leaves area and new one comes in
//						 RandReplaceRow = jRow();
//						 RandReplaceCol = jCol();
//						 
//						 
//						 boolean goActive = randState();
//						 if(goActive == true){
//						receptorArray[i][0] = 1.0f;
//						 }
//						 else{
//							 receptorArray[i][0] = 0.0f;
//						 }
						//receptorArray[i][1] = RandReplaceRow;
						//receptorArray[i][2] = RandReplaceCol;
						//System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray)); 
						//System.out.println("111after hop x: "+receptorArray[i][1]);
						//System.out.println("111after hop y: "+receptorArray[i][2]);
						
						//checkHopArray(i);
						//System.out.println("111after checkHopArray x: "+receptorArray[i][1]);
						//System.out.println("111after checkHopAray y: "+receptorArray[i][2]);
					 }
					 else{			  //don't hop
					
						 //System.out.println("555don't hop BEFORE correction: "+Arrays.deepToString(receptorArray));
						 
						 receptorArray[i][1] = 0;
						 //receptorArray[i][1] = (0 + stepSize);
					 //System.out.println("555don't hop AFTER correction: "+Arrays.deepToString(receptorArray));
					 }
				 }
				 
				 //BOUNDARY CHECKING
				 else if(receptorArray[i][1] < width && receptorArray[i][1] > 0 && receptorArray[i][2] > 0 
						 && receptorArray[i][2] < height && previousReceptorArray[i][1] >= width){	//hop in from left
					
					 
					 //System.out.println("222before hop x: "+receptorArray[i][1]);
					 //System.out.println("222before hop y: "+receptorArray[i][2]);
					 boolean hop = hopProbability();
					 if(hop == true){  //hop inside
						 //System.out.println("666prevRecArray BEFORE hop: "+Arrays.deepToString(previousReceptorArray));
						 //System.out.println("666receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
									 
						 hopInXLocationArray.add((float) width);
						 hopInYLocationArray.add(receptorArray[i][2]);
						 hops++;
						 hopArray.add(hops);
						 hopTimeArray.add((float) mm*timeStep);
						// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
						 if(receptorArray[i][0] == 1.1f){
							 receptorArray[i][0] = 1.0f;
						 }
						 else if(receptorArray[i][0] == 0.1f){
							 receptorArray[i][0] = 0.0f;
						 }
						 //System.out.println("666prevRecArray AFTER hop: "+Arrays.deepToString(previousReceptorArray));
						 //System.out.println("666receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
						 
	//**for regenerating a new receptor when one hops, but may use later**// 
						 //when one receptor leaves area and new one comes in
//						 RandReplaceRow = jRow();
//						 RandReplaceCol = jCol();
//						 
//						
//						 boolean goActive = randState();
//						 if(goActive == true){
//						 receptorArray[i][0] = 1.0f;
//						 }
//						 else{
//							 receptorArray[i][0] = 0.0f;
//						 }
						//receptorArray[i][1] = RandReplaceRow;
						//receptorArray[i][2] = RandReplaceCol;		
						//System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray));
						//System.out.println("222after hop x: "+receptorArray[i][1]);
						//System.out.println("222after hop y: "+receptorArray[i][2]);
					
						//checkHopArray(i);
						//System.out.println("222after checkHopArray x: "+receptorArray[i][1]);
						//System.out.println("222after checkHopArray y: "+receptorArray[i][2]);
					 }
					 else{			   //don't hop
						 //System.out.println("666don't hop BEFORE correction: "+Arrays.deepToString(receptorArray));
					receptorArray[i][1] = width;
					//receptorArray[i][1] = (width + stepSize);
					 //System.out.println("666don't hop AFTER correction: "+Arrays.deepToString(receptorArray));
					 }
				 } 
				 /////////////////receptorArray[i][2] = receptorArray[i][2] + moveArray[i][2];
				 
				 //BOUNDARY CHECKING		
				 if(receptorArray[i][2] > 0 && receptorArray[i][2] < height && receptorArray[i][1] > 0 
						 && receptorArray[i][1] < width && previousReceptorArray[i][2] <= 0){  //hop in from bottom
					 
					 
					//System.out.println("333before hop x: "+receptorArray[i][1]);
					//System.out.println("333before hop y: "+receptorArray[i][2]);
					 boolean hop = hopProbability();
					 if(hop == true){  //hop inside
						//System.out.println("777prevRecArray BEFORE hop: "+Arrays.deepToString(previousReceptorArray));
						//System.out.println("777receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
											 
						 hopInXLocationArray.add(receptorArray[i][1]);
						 hopInYLocationArray.add(0.0f);
						 hops++;
						 hopArray.add(hops);
						 hopTimeArray.add((float) mm*timeStep);
						// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
						 if(receptorArray[i][0] == 1.1f){
							 receptorArray[i][0] = 1.0f;
						 }
						 else if(receptorArray[i][0] == 0.1f){
							 receptorArray[i][0] = 0.0f;
						 }
						 //System.out.println("777prevRecArray AFTER hop: "+Arrays.deepToString(previousReceptorArray));
						 //System.out.println("777receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
						 
	//**for regenerating a new receptor when one hops, but may use later**//
						 //when one receptor leaves area and new one comes in
//						 RandReplaceRow = jRow();
//						 RandReplaceCol = jCol();
//					
//						
//						 boolean goActive = randState();
//						 if(goActive == true){
//						 receptorArray[i][0] = 1.0f;
//						 }
//						 else{
//							 receptorArray[i][1] = 0.0f;
//						 }
						//receptorArray[i][1] = RandReplaceRow;
						//receptorArray[i][2] = RandReplaceCol;	
						//System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray));
						//System.out.println("333after hop x: "+receptorArray[i][1]);
						//System.out.println("333after hop y: "+receptorArray[i][2]);
					
						//checkHopArray(i);
						//System.out.println("333after checkHopArray x: "+receptorArray[i][1]);
						//System.out.println("333after checkHopArray y: "+receptorArray[i][2]);
					 }
					 else{			   //don't hop
						 //System.out.println("777don't hop BEFORE correction: "+Arrays.deepToString(receptorArray));
						 receptorArray[i][2] = 0;
						 //receptorArray[i][2] = (0 - stepSize);
					 //System.out.println("777don't hop AFTER correction: "+Arrays.deepToString(receptorArray));
					 }
				 }
				 
				 //BOUNDARY CHECKING
				 else if(receptorArray[i][2] < height && receptorArray[i][2] > 0 && receptorArray[i][1] > 0
						 && receptorArray[i][1] < width && previousReceptorArray[i][2] >= height){ //hop in from top
					 
					 
					 //System.out.println("444before hop x: "+receptorArray[i][1]);
					 //System.out.println("444before hop y: "+receptorArray[i][2]);
					 boolean hop = hopProbability();
					 if(hop == true){  //hop inside
						 //System.out.println("888prevRecArray BEFORE hop: "+Arrays.deepToString(previousReceptorArray));
						 //System.out.println("888receptorArray BEFORE hop: "+Arrays.deepToString(receptorArray));
						
						 
						 hopInXLocationArray.add(receptorArray[i][1]);
						 hopInYLocationArray.add((float) height);
						 hops++;
						 hopArray.add(hops);
						 hopTimeArray.add((float) mm*timeStep);
						// System.out.println("receptorArray at hop location"+Arrays.deepToString(receptorArray));
						 if(receptorArray[i][0] == 1.1f){
							 receptorArray[i][0] = 1.0f;
						 }
						 else if(receptorArray[i][0] == 0.1f){
							 receptorArray[i][0] = 0.0f;
						 }
						// System.out.println("888prevRecArray AFTER hop: "+Arrays.deepToString(previousReceptorArray));
						// System.out.println("888receptorArray AFTER hop: "+Arrays.deepToString(receptorArray));
						 
	//**for regenerating a new receptor when one hops, but may use later**//
						 //when one receptor leaves area and new one comes in
//						 RandReplaceRow = jRow();
//						 RandReplaceCol = jCol();
//						 
//						
//						 boolean goActive = randState();
//						 if(goActive == true){
//							 receptorArray[i][0] = 1.0f;				 
//						 }
//						 else{
//							 receptorArray[i][0] = 0.0f;
//						 }
						
						 //receptorArray[i][1] = RandReplaceRow;
						 //receptorArray[i][2] = RandReplaceCol;	
						 //System.out.println("newly generated receptorArray: "+Arrays.deepToString(receptorArray));
						 //System.out.println("444after hop x: "+receptorArray[i][1]);
						 //System.out.println("444after hop y: "+receptorArray[i][2]);
					
						 //checkHopArray(i);
						 //System.out.println("444after checkHopArray x: "+receptorArray[i][1]);
						 //System.out.println("444after checkHopArray y: "+receptorArray[i][2]);
					 }
					 else{			   //don't hop
					// System.out.println("888don't hop BEFORE correction: "+Arrays.deepToString(receptorArray));
					 receptorArray[i][2] = height;
					 //receptorArray[i][2] = (height+ stepSize);
					// System.out.println("888don't hop AFTER correction: "+Arrays.deepToString(receptorArray));
					 }
				 }  
		//Boundary conditions if goes past outer edge, disappears and generate new at random edge location
				 else if(receptorArray[i][1] < (0 - gap)){  //pass left edge				 
					 edgeGeneration(i);
					 
				 }
				 else if(receptorArray[i][1] > (width + gap)){  //pass right edge
					 edgeGeneration(i);
				 }
				 else if(receptorArray[i][2] < (0 - gap)){  //pass bottom edge
					 edgeGeneration(i);
				 }
				 else if(receptorArray[i][2] > (height + gap)){  //pass top edge
					 edgeGeneration(i);
				 }

/////////////////***zz				 
//				 xElements = receptorArray[i][1];//////////////////////////zz
//				 yElements = receptorArray[i][2];//////////////////////////zz
//				//System.out.println("moveArray size: "+(moveArray.length-1));
//				//System.out.println("xElement: "+xElements);
//						 
//				 xArray.add(xElements);///////////////////////////////////zz
//				 yArray.add(yElements);///////////////////////////////////zz
//				//System.out.println("hopTimeArray: "+hopTimeArray);
//				 // System.out.println("xArray is: ");
//				// System.out.println(xArray);
/////////////////***zz				 
				 
			 }///////// **END OF if(0.1f or 1.1f)**///////
		  
		  
		  
		  }////////////////////end of for loop
	
		 
		 //clear moveArray after ALL moveArray per receptor have been added
		 for(int j = 0; j < moveArray.length; j++){
				Arrays.fill(moveArray[j], '\0');
			}
		 
			//System.out.println("hopXLocationArray"+hopXLocationArray);
			//System.out.println("hopYLocationArray"+hopYLocationArray);
			// System.out.println("AAAAAAAAAAAAAAAAAAAAAAAA  AFTER BOUND CHECK new receptor array is: ");
			//System.out.println("Final receptorArray: "+Arrays.deepToString(receptorArray));
			// System.out.println("xArray is: ");
			// System.out.println(xArray);
			// System.out.println("yArray is: ");
			// System.out.println(yArray);
		 
		 } ////////addArrays() end
	 
	 public static void edgeGeneration(int index){
		 
		 int xEdge = 0;
		 int yEdge = 0;
		 Random rand = new Random();
		 int randSide = rand.nextInt(4);
		 if(randSide == 0){ //bottom
			//from + rand.nextInt(to - from + 1)
		
			xEdge = (0 - gap) + rand.nextInt( (width + gap) - (0 - gap) + 1 );
			yEdge = (0 - gap);
			
			receptorArray[index][1] = xEdge;
			receptorArray[index][2] = yEdge;
			
			boolean goActive = randState();
			if(goActive == true){
				receptorArray[index][0] = 1.1f;		
			}
			else{
				receptorArray[index][0] = 0.1f;
			}
			
		 }
		 if(randSide == 1){ //left
			//from + rand.nextInt(to - from + 1)
			 
			 xEdge = (0 - gap);
			 yEdge = (0 - gap) + rand.nextInt( (height + gap) - (0 - gap) + 1);
			 
			 receptorArray[index][1] = xEdge;
			 receptorArray[index][2] = yEdge;
			 
			 boolean goActive = randState();
				if(goActive == true){
					receptorArray[index][0] = 1.1f;		
				}
				else{
					receptorArray[index][0] = 0.1f;
				}
		 }
		 if(randSide == 2){ //top
			//from + rand.nextInt(to - from + 1)
			 
			 xEdge = (0 - gap) + rand.nextInt( (width + gap) - (0 - gap) + 1 );
			 yEdge = (height + gap);
			 
			 receptorArray[index][1] = xEdge;
			 receptorArray[index][2] = yEdge;
			 
			 boolean goActive = randState();
				if(goActive == true){
					receptorArray[index][0] = 1.1f;		
				}
				else{
					receptorArray[index][0] = 0.1f;
				}
		 }
		 if(randSide == 3){ // right
			//from + rand.nextInt(to - from + 1)
			 
			 xEdge = (width + gap);
			 yEdge = (0 - gap) + rand.nextInt( (height + gap) - (0 - gap) + 1 );
			 
			 receptorArray[index][1] = xEdge;
			 receptorArray[index][2] = yEdge;
			 
			 boolean goActive = randState();
				if(goActive == true){
					receptorArray[index][0] = 1.1f;		
				}
				else{
					receptorArray[index][0] = 0.1f;
				}			 
		 }
		
	 }
		
 public static void dimerEdgeGeneration(int index1, int index2){
		 
		 int xEdge1 = 0;
		 int yEdge1 = 0;
		 
		 int xEdge2 = 0;
		 int yEdge2 = 0;
		 
		 Random rand = new Random();
		 int randSide = rand.nextInt(4);
		 if(randSide == 0){ //bottom
			//from + rand.nextInt(to - from + 1)
		
			xEdge1 = (0 - gap) + rand.nextInt( (width + gap) - (0 - gap) + 1 );
			yEdge1 = (0 - gap);
			
			xEdge2 = (0 - gap) + rand.nextInt( (width + gap) - (0 - gap) + 1 );
			yEdge2 = (0 - gap);
			
			receptorArray[index1][1] = xEdge1;
			receptorArray[index1][2] = yEdge1;
			
			receptorArray[index2][1] = xEdge2;
			receptorArray[index2][2] = yEdge2;
			
			
			boolean goActive1 = randState();
			if(goActive1 == true){
				receptorArray[index1][0] = 1.1f;		
			}
			else{
				receptorArray[index1][0] = 0.1f;
			}
			
			boolean goActive2 = randState();
			if(goActive2 == true){
				receptorArray[index2][0] = 1.1f;		
			}
			else{
				receptorArray[index2][0] = 0.1f;
			}
		 }
		 if(randSide == 1){ //left
			//from + rand.nextInt(to - from + 1)
			 
			 xEdge1 = (0 - gap);
			 yEdge1 = (0 - gap) + rand.nextInt( (height + gap) - (0 - gap) + 1);
			 
			 xEdge2 = (0 - gap);
			 yEdge2 = (0 - gap) + rand.nextInt( (height + gap) - (0 - gap) + 1);
			 
			 receptorArray[index1][1] = xEdge1;
			 receptorArray[index1][2] = yEdge1;
			 
			 receptorArray[index2][1] = xEdge2;
			 receptorArray[index2][2] = yEdge2;
			 
			 boolean goActive1 = randState();
				if(goActive1 == true){
					receptorArray[index1][0] = 1.1f;		
				}
				else{
					receptorArray[index1][0] = 0.1f;
				}
				boolean goActive2 = randState();
				if(goActive2 == true){
					receptorArray[index2][0] = 1.1f;		
				}
				else{
					receptorArray[index2][0] = 0.1f;
				}
		 }
		 if(randSide == 2){ //top
			//from + rand.nextInt(to - from + 1)
			 
			 xEdge1 = (0 - gap) + rand.nextInt( (width + gap) - (0 - gap) + 1 );
			 yEdge1 = (height + gap);
			 
			 xEdge2 = (0 - gap) + rand.nextInt( (width + gap) - (0 - gap) + 1 );
			 yEdge2 = (height + gap);
			 
			 receptorArray[index1][1] = xEdge1;
			 receptorArray[index1][2] = yEdge1;
			 
			 receptorArray[index2][1] = xEdge2;
			 receptorArray[index2][2] = yEdge2;
			 
			 boolean goActive1 = randState();
				if(goActive1 == true){
					receptorArray[index1][0] = 1.1f;		
				}
				else{
					receptorArray[index1][0] = 0.1f;
				}
				boolean goActive2 = randState();
				if(goActive2 == true){
					receptorArray[index2][0] = 1.1f;		
				}
				else{
					receptorArray[index2][0] = 0.1f;
				}
		 }
		 if(randSide == 3){ // right
			//from + rand.nextInt(to - from + 1)
			 
			 xEdge1 = (width + gap);
			 yEdge1 = (0 - gap) + rand.nextInt( (height + gap) - (0 - gap) + 1 );
			 
			 xEdge2 = (width + gap);
			 yEdge2 = (0 - gap) + rand.nextInt( (height + gap) - (0 - gap) + 1 );
			 
			 receptorArray[index1][1] = xEdge1;
			 receptorArray[index1][2] = yEdge1;
			 
			 receptorArray[index2][1] = xEdge2;
			 receptorArray[index2][2] = yEdge2;
			 
			 boolean goActive1 = randState();
				if(goActive1 == true){
					receptorArray[index1][0] = 1.1f;		
				}
				else{
					receptorArray[index1][0] = 0.1f;
				}			 
				 boolean goActive2 = randState();
					if(goActive2 == true){
						receptorArray[index2][0] = 1.1f;		
					}
					else{
						receptorArray[index2][0] = 0.1f;
					}			 
		 }
		
	 }

	 public static synchronized boolean eventCheck(){
		 
		 Random rand = new Random();
		 
		 for(int i = 0; i <= receptorArray.length - 1; i++){
			 for(int j = 0; j <= receptorArray.length - 1; j++){
				 
				 if(receptorArray[i][0] == 1.0f && receptorArray[j][0]== 1.0f && receptorArray[i][1] == receptorArray[j][1] && receptorArray[i][2] == receptorArray[j][2] && i != j){
					 //if there is event, long straight line on plot,
					 //indicates path between endo receptors and newly generated receptors
					
					 
					// System.out.println("receptor 1 Active: "+receptorArray[i][0]);
					// System.out.println("receptor 2 Active: "+receptorArray[j][0]);
					 
					 
					 events++;
					 //System.out.println("Total number of events: "+events);
					 
					 eventXLocationArray.add(receptorArray[j][1]);
					 eventYLocationArray.add(receptorArray[j][2]);
					 
					 //Replace matching positions two new receptors
					 ///***FOR EDGE GENERATION***///
				
					 dimerEdgeGeneration(i,j);
					 
					 
					 ///***FOR RANDOM POSITION GENERATION WITHIN INNER AREA***///
					 
//					    int iRandReceptor = rand.nextInt(2); 
//						int iRandRow = rand.nextInt(height);
//						int iRandCol = rand.nextInt(width);
//					
//						receptorArray[i][0] = iRandReceptor;
//						receptorArray[i][1] = iRandRow;
//						receptorArray[i][2] = iRandCol;	
//						
//						int jRandReceptor = rand.nextInt(2);
//						int jRandRow = rand.nextInt(height);
//						int jRandCol = rand.nextInt(width);
//						
//						receptorArray[j][0] = jRandReceptor;
//						receptorArray[j][1] = jRandRow;
//						receptorArray[j][2] = jRandCol;
										 
						return true;
				 }
				 
			 }		 
		 }
		 //System.out.println("EVENT ARRAY IS: "+eventArray);
		 //System.out.println("Number of Events: "+events);
		return false;
		
	 }///////eventCheck() end
	 
	 public static void plotTrajectory(){
/////////////////////////////////////////zz 
//		 ArrayList<ArrayList<Float>> xFinalArray = new ArrayList<ArrayList<Float>>(); 
//		 ArrayList<ArrayList<Float>> yFinalArray = new ArrayList<ArrayList<Float>>(); 
//	
//		 float xP = 0.0f;
//		 float yP = 0.0f;
//		
//		 float[][] xPlot = new float[nReceptors][move];
//		 float[][] yPlot = new float[nReceptors][move];
	
/////////////////////////////////////////zz
	 
		 float xOutL = 0.0f;
		 float yOutL = 0.0f;
		 float[] xOutLocation = new float[hopOutXLocationArray.size()];
		 float[] yOutLocation = new float[hopOutYLocationArray.size()];
		 
		 float xInL = 0.0f;
		 float yInL = 0.0f;
		 float[] xInLocation = new float[hopInXLocationArray.size()];
		 float[] yInLocation = new float[hopInYLocationArray.size()];
		 
		 float xE = 0.0f;
		 float yE = 0.0f;
		 float[] xEvent = new float[eventXLocationArray.size()];
		 float[] yEvent = new float[eventYLocationArray.size()];
		// System.out.println("eventXLocationArray"+eventXLocationArray);
		// System.out.println("eventyLocationArray"+eventYLocationArray);
		 
		 
//		 System.out.println("nReceptors: "+nReceptors);
//		 System.out.println("move: "+move);
//		 System.out.println("xArray is: "+xArray);
//		 System.out.println("xArray.size(): "+xArray.size());
//		 System.out.println("yArray is: "+yArray);
//		 System.out.println("yArray.size(): "+yArray.size());
		 
	
		 
		 int a = 0;  //set a from 1 to 0, fixes odd loop issue
		 //System.out.println("Before even/odd for loop xArray: "+xArray);
		 //System.out.println("Before even/odd for loop yArray: "+yArray);
/////////////////////////////////////////zz
//		 if((xArray.size())%2 == 0){  //even
//		 	for(int i = 0; i <= nReceptors - 1; i++){
//		 		
//		 		//create new array for each ith set of positions
//		 		ArrayList<Float> xFinalInnerArray = new ArrayList<Float>(); 
//		 		ArrayList<Float> yFinalInnerArray = new ArrayList<Float>(); 
//		 		for(int j = 0 + i; j <= xArray.size() - 1; j+= nReceptors){
//				 
//		 			//System.out.println("even");
//		 			//System.out.println("xArray.get(j): "+xArray.get(j)+" at j index "+ j + " i = "+i);
//		 			
//		 			xFinalInnerArray.add(xArray.get(j));
//		 			yFinalInnerArray.add(yArray.get(j));
//		 			
//		 		}
//		 	//System.out.println("xFinalInnerArray: " +xFinalInnerArray);
//		 	//System.out.println("yFinalInnerArray: "+yFinalInnerArray);
//		 	xFinalArray.add(xFinalInnerArray);
//		 	yFinalArray.add(yFinalInnerArray);
//		 	//System.out.println("xFinalArray: "+xFinalArray);
//		 	//System.out.println("yFinalArray: "+yFinalArray);
//		 	}
//		 	//System.out.println("aaaxFinalArray: "+xFinalArray);
//			//System.out.println("aaayFinalArray: "+yFinalArray);
//		 }
//		 	 
//		 else{    //odd
//			 for(int i = 0; i <= nReceptors - 1; i++){
//				 
//				//create new array for each ith set of positions
//		 		 ArrayList<Float> xFinalInnerArray = new ArrayList<Float>(); 
//		 		 ArrayList<Float> yFinalInnerArray = new ArrayList<Float>(); 
//		 		 
//			 		for(int j = 0 + i; j <= (xArray.size() - (nReceptors - a )); j+= nReceptors){
//					 
//			 			//System.out.println("odd");
//			 			//System.out.println("xArray.get(j): "+xArray.get(j)+" at j index "+ j+ " i = "+i);
//			 			
//			 			xFinalInnerArray.add(xArray.get(j));////////
//			 			yFinalInnerArray.add(yArray.get(j));
//					
//				 }
//			 		//System.out.println("a: "+a);
//			 		a++;
//			 		//System.out.println("xFinalInnerArray:" +xFinalInnerArray);
//				 	xFinalArray.add(xFinalInnerArray);
//				 	yFinalArray.add(yFinalInnerArray);
//				 	//System.out.println("xFinalArray: "+xFinalArray);
//				 	//System.out.println("yFinalArray: "+yFinalArray);
//			 }
//		 } 
//		 
//		//System.out.println("bbbxFinalArray: "+xFinalArray);
//		//System.out.println("bbbyFinalArray: "+yFinalArray);
//		
//		 	
//	for(int i = 0; i<=xFinalArray.size() - 1; i++){	 	
//	
//		 Float[] xO = xFinalArray.get(i).toArray(new Float[xFinalArray.size()]);
//		 Float[] yO = yFinalArray.get(i).toArray(new Float[yFinalArray.size()]);
//		 
//		 for(int j = 0; j <= xFinalArray.get(i).size() - 1; j++){
//						
//			// System.out.println("xO: "+xO[j]);
//			// System.out.println("yO: "+yO[j]);
//			 xP = xO[j].floatValue();
//			 yP = yO[j].floatValue();
//			 
//			 xPlot[i][j] = xP;
//			 yPlot[i][j] = yP;
//			 //System.out.println("xP: "+xP);
//			 //System.out.println("yP: "+yP);
//			 
//		 }
//	}	
//System.out.println("xPlot"+Arrays.deepToString(xPlot));
//System.out.println("yPlot"+Arrays.deepToString(yPlot));

//Hopping out
	for(int i = 0; i <= hopOutXLocationArray.size() - 1; i++){
		
		xOutL = hopOutXLocationArray.get(i).floatValue();
		yOutL = hopOutYLocationArray.get(i).floatValue();
		
		xOutLocation[i] = xOutL;
		yOutLocation[i] = yOutL;		
	}

//Hopping in
	for(int i = 0; i <= hopInXLocationArray.size() - 1; i++){
		
		xInL = hopInXLocationArray.get(i).floatValue();
		yInL = hopInYLocationArray.get(i).floatValue();
		
		xInLocation[i] = xInL;
		yInLocation[i] = yInL;
	}
	
	
	for(int i = 0; i<= eventXLocationArray.size() - 1; i++){
		
		xE = eventXLocationArray.get(i).floatValue();
		yE = eventYLocationArray.get(i).floatValue();
		
		xEvent[i] = xE;
		yEvent[i] = yE;
		
	}
	
		//System.out.println(Arrays.deepToString(xPlot));  
		//System.out.println(Arrays.deepToString(yPlot));
	
		//System.out.println("R1 first point: "+xPlot[0][1]+" , "+yPlot[0][2]);
		
//		 Plot positionPlot = new Plot("positionPlot","X position (nm)","Y position (nm)",xPlot[0],yPlot[0]);//zz
		 Plot positionPlot = new Plot("positionPlot","X position (nm)","Y position (nm)");
//		 //line width for dotted boundary line
		 
		 //draw inner boundary 
		 positionPlot.setLineWidth(2);
		 positionPlot.setColor(Color.BLUE);
		 positionPlot.drawLine(0.0, 0.0, width, 0.0);
		 positionPlot.drawLine(0.0, 0.0, 0.0, height);
		 positionPlot.drawLine(width, height,0.0,height );
		 positionPlot.drawLine(width, height, width, 0.0);
		 
//		//draw outer boundary
		 positionPlot.setLineWidth(2);
		 positionPlot.setColor(Color.RED);
		 positionPlot.drawLine(0.0-gap, 0.0-gap, width+gap, 0.0-gap);
		 positionPlot.drawLine(0.0-gap, 0.0-gap, 0.0-gap, height+gap);
		 positionPlot.drawLine(width+gap, height+gap,0.0-gap,height+gap );
		 positionPlot.drawLine(width+gap, height+gap, width+gap, 0.0-gap);
		 
		 //tested for squares only, not for rectangles, make sure height = width
//		 positionPlot.setLineWidth(2);
//		 positionPlot.setColor(Color.BLUE);
//		 positionPlot.drawLine( ((outerHeight - height)/2)*-1, ((outerHeight - height)/2)*-1, ((outerHeight - height)/2)+height, ((outerHeight - height)/2)*-1 );
//		 positionPlot.drawLine( ((outerWidth - width)/2)*-1, ((outerWidth - width)/2)*-1, ((outerWidth - width)/2)*-1, ((outerWidth - width)/2)+width );
//		 positionPlot.drawLine( ((outerHeight - height)/2)*-1, ((outerHeight - height)/2)+height,((outerHeight - height)/2)+height, ((outerHeight - height)/2)+height );
//		 positionPlot.drawLine( ((outerWidth - width)/2)+width, ((outerWidth - width)/2)*-1, ((outerWidth - width)/2)+width, ((outerWidth - width)/2)+width );
		 
		 
		 
		 positionPlot.setColor(Color.BLACK);  //  color for first receptor data set
		 positionPlot.setLimits( (0 - gap) - 50, (width + gap) + 50, (0 - gap) - 50, (height + gap) + 50); //x1,x2,y1,y2
		//show() pertains to drawing first data set
		//so set parameters for first data set before testPlot.show()
		 //line width for first receptor data set 	 
		 positionPlot.setLineWidth(2);
		 
		 positionPlot.show();  
		 
		 //additional data sets
		 //set methods apply to the first data set it encounters
		 //so put directly before method that draws respective data set
		 
//		 for(int i = 1; i<=nReceptors - 1; i++){	 /////////zz
//				//line width for subsequent receptors 
//				
//			 
//			 	positionPlot.setLineWidth(2);
//				positionPlot.setColor(Color.GRAY);
//				positionPlot.addPoints(xPlot[i],yPlot[i],2); 
//				//System.out.println("plot receptor: "+i);		
//				
//				
//			 }/////////zz
//		 

		 
//		 	positionPlot.setLineWidth(1);
//			positionPlot.setColor(Color.GREEN);
//			positionPlot.addPoints(xPlot[1],yPlot[1],2); 
//			
//			positionPlot.setLineWidth(1);
//			positionPlot.setColor(Color.RED);
//			positionPlot.addPoints(xPlot[2],yPlot[2],2); 
			
			
		 //System.out.println(xPlot.length);
		 //System.out.println(nReceptors);
		 //skip first data set, already plotted (i=1)
				 
		 positionPlot.setLineWidth(3);
		 positionPlot.setColor(Color.MAGENTA);
		 positionPlot.addPoints(xOutLocation,yOutLocation, 0);
		 
		 positionPlot.setLineWidth(3);
		 positionPlot.setColor(Color.GREEN);
		 positionPlot.addPoints(xInLocation, yInLocation, 1);
		 
		 positionPlot.setLineWidth(2);
		 positionPlot.setColor(Color.RED);
		 positionPlot.addPoints(xEvent, yEvent, 0);
		 

	 }/////////plotTrajectory() end
	 
	 
	public static void plotEvents(){
		
		float xP2 = 0f;
		float yP2 = 0f;
		float yP2Change = 0f;
		float[] xEvent = new float[timePointArray.size()]; 
		float[] yEvent = new float[collisionArray.size()];
		float[] yEventChange = new float[collisionPerTimeArray.size()];
		
		for(int i = 0; i<= collisionArray.size() - 1; i++){
			
		  xP2 =	timePointArray.get(i).floatValue();
		  yP2 = collisionArray.get(i).floatValue();
		  yP2Change = collisionPerTimeArray.get(i).floatValue();
		 
		  xEvent[i] = ((1+steps)*xP2);
		  yEvent[i] = yP2;
		  yEventChange[i] = yP2Change;
		  
		  
		}
		
		
		Plot eventPlot = new Plot("Total Events vs. Time","Time (s)","Total Number of Dimerizations");
		
		eventPlot.setLineWidth(2);
		eventPlot.setColor(Color.RED);
		eventPlot.addPoints(xEvent, yEvent, 0);
		
		eventPlot.show();
		
		

		Plot eventChangePlot = new Plot("Events vs. time","Time (s) ","Dimerizations");
		eventChangePlot.setLineWidth(2);
		eventChangePlot.setColor(Color.BLUE);
		eventChangePlot.addPoints(xEvent, yEventChange, 0);
		eventChangePlot.show();
	 }////////plotEvents() end
	 
	public static void plotStates(){
		
		//plotting for states of first receptor
		//System.out.println(Arrays.toString(copyTotalTimeArray[0]));
		
		for(int i = 0; i <= copyTotalTimeArray[0].length - 1; i++){
			//+1 for the moveArray, which is first move in iteration
			copyTotalTimeArray[0][i] = ((1+steps)*copyTotalTimeArray[0][i]);  //only adds step to first timeArray for 
		}																	  //for one receptor for plot
		//System.out.println("new array:" +Arrays.toString(copyTotalTimeArray[0]));
		Plot statePlot = new Plot("State vs. Time", "Time (s)","State",copyTotalTimeArray[0],stateArray[0],2);
		statePlot.setLineWidth(2);
		statePlot.setColor(Color.RED);

		
		//plotting states of remaining receptors
		  int count = 1;
	  for(int i = 1; i <= stateArray.length - 1 ; i++){
		for(int j = 0; j <= stateArray[i].length - 1; j++){
			
			//System.out.println("stateArray[i] BEFORE mod: "+Arrays.toString(stateArray[i]));
		
			stateArray[i][j] = stateArray[i][j] - (count*4.0f);
			
			//System.out.println("stateArray[i] AFTER mod: "+Arrays.toString(stateArray[i]));
		}
		count++;
	  }
		
		
		statePlot.setLineWidth(2);
	for(int i = 0; i <= stateArray.length - 1; i++){
		statePlot.addPoints(copyTotalTimeArray[i], stateArray[i], 2);
	}
	statePlot.setLimits(0,totalTime, -(nReceptors*4), 4);
		//statePlot.addPoints( copyTotalTimeArray[0] ,stateArray[0]  , 2);
		//System.out.println(Arrays.deepToString(stateArray));
		//System.out.println(Arrays.deepToString(copyTotalTimeArray));
	
		
		
		statePlot.show();
	}
	//////*****SET nRECEPTOR to 1 before plotting state changes, currently combines states into same array*****
	//*****Make 2D array if want to plot state changes while running with a lot of receptors*****
	public static void plotStateChanges(){
		
		float xT = 0.0f;
		float yS = 0.0f;
		
		//System.out.println(switchTimeArray.size());
		//System.out.println(switchStateArray.size());

		
		
		float[] xTime = new float[switchTimeArray.size()];
		float[] yState = new float[switchStateArray.size()];
		
		for(int i = 0; i <=switchTimeArray.size() - 1; i++){
			
			xT = switchTimeArray.get(i).floatValue();
			yS = switchStateArray.get(i).floatValue();
			
			xTime[i] = ((1+steps)*xT);
			yState[i] = yS;
			
			
		}
		
		Plot stateChangePlot = new Plot("State Change vs. Time", "Time (s)","State");
		stateChangePlot.setLineWidth(2);
		stateChangePlot.setColor(Color.RED);
		//stateChangePlot.setLimits(0,totalTime, -1,2);
		stateChangePlot.addPoints(xTime,yState , 2);
		
		stateChangePlot.show();
		
		
	}
	
	public static void plotHop(){
		
		System.out.println("hopArray: "+hopArray);
		//System.out.println("hopTimeArray: "+hopTimeArray);
		
		
		float xH = 0.0f;
		float yH = 0.0f;
		
		//For some reason, plot doesn't generate if there is just one hop, so add plot 0 hop initially
		//maybe need more than one data point per array? hence +1 
		float[] xHop = new float[hopTimeArray.size()+1];
		float[] yHop = new float[hopArray.size()+1];
		xHop[0] = 0.0f;
		yHop[0] = 0.0f;
	
		for(int i = 0; i <= hopTimeArray.size() - 1 ; i++){
			
			xH = hopTimeArray.get(i).floatValue();
			yH = hopArray.get(i).floatValue();
		
			
			xHop[i] = ((1 + steps)*xH);
			yHop[i] = yH;
			
		}
		System.out.println("xHop: "+Arrays.toString(xHop));
		System.out.println("yHop: "+Arrays.toString(yHop));
		//No plot shows up if there is only one hop?
		Plot totalHopPlot = new Plot("Total Number of Hops vs. Time"  ,"Time (s)"," Number of Hops ");
		totalHopPlot.setLineWidth(2);
		totalHopPlot.setColor(Color.RED);
		totalHopPlot.addPoints(xHop, yHop, 0);
		
		
		totalHopPlot.show();
		
	}
	
}//Diffusion class end
